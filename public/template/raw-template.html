<!DOCTYPE html>
<html lang="de">
<!--######## HTML-Template - StreamShapers #######-->
<!--########### visit streamshapers.com ##########-->
<!-- made with StreamShapers Ferryman ${version} -->
<head>
    <meta charset='utf-8'>
    <title>Lottie Template 01</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <style>
        html {
            overflow: hidden;
        }

        body {
            margin: 0;
            width: 100vw;
        }

        p {
            font-size: 30px;
            margin: 0 0 0 20px;
            color: white
        }

        h1 {
            margin-left: 20px;
            color: white
        }
    </style>
    ${fontFaceStyles}
    ${spx}
    <script>
        function updateTimeField(animation) {
            const svgDocument = document.getElementById(animation).querySelector('svg');
            const gElements = svgDocument.getElementsByTagName('g');
            const formatMap = {
                'cc:cc:cc': 'HH:mm:ss',
                'cc:cc': 'HH:mm',
            };

            for (let g of gElements) {
                const ariaLabel = g.getAttribute('aria-label');
                const format = formatMap[ariaLabel];

                if (format) {
                    const textElements = Array.from(g.getElementsByTagName('text'));

                    function updateTime() {
                        const now = new Date();
                        let formattedTime;

                        if (format === 'HH:mm:ss') {
                            formattedTime = now.toLocaleTimeString();
                        } else if (format === 'HH:mm') {
                            formattedTime = now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                        }

                        const timeParts = formattedTime.split(':');

                        if (timeParts.length >= 2) {
                            textElements[0].textContent = timeParts[0][0];
                            textElements[1].textContent = timeParts[0][1];
                            textElements[2].textContent = ':';
                            textElements[3].textContent = timeParts[1][0];
                            textElements[4].textContent = timeParts[1][1];

                            if (timeParts.length === 3 && format === 'HH:mm:ss') {
                                textElements[5].textContent = ':';
                                textElements[6].textContent = timeParts[2][0];
                                textElements[7].textContent = timeParts[2][1];
                            }
                        }
                    }

                    setInterval(updateTime, 1000);
                    updateTime();
                }
            }
        }
    </script>
</head>

<body>
<div id="animation1"></div>
<!--Animations-Script-->
<script>
    //Google Table integration
    // SHEET_ID = "1Ta6xX9ZVGEQXY5K3uqpCSlqXr6r6Ixqpr91-WcAR1IA";
    // SHEET_TITLE = "Tabellenblatt1";
    //const sheetURL = 'https://docs.google.com/spreadsheets/d/' + SHEET_ID + '/gviz/tq?sheet=' + SHEET_TITLE;

    const googleTableCells = '${googleTableData}';
    /*googleTableCells.push({
        id:"id",
        key: "_value1",
        cell: "A1",
        value:"default"
    })*/

    async function parseGoogleTable(){
        return JSON.parse(googleTableCells);
    }

    async function fetchDataFromGoogle(url) {
        try {
            let response = await fetch(url);
            let text = await response.text();
            let jsonString = text.substr(47).slice(0, -2);
            let parsed = JSON.parse(jsonString);
            const dataArray = [];

            parsed.table.rows.forEach(row => {
                let columns = [];
                row.c.forEach(cell => {
                    columns.push(cell ? cell.v : null); // Check if cell is not null
                });
                dataArray.push(columns);
            });
            //console.log(dataArray);
            return dataArray;
        }catch (error) {
            console.error("Error collecting data from Google: ", error);
            return [];
        }
    }

    function getCellData(cell,data) {
        const columnName = cell.match(/[A-Z]+/g)[0];
        const base = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let rowIx = (parseInt(cell.match(/[0-9]+/g)[0]))-1; //incl. index Shift (-1)
        let colIx = 0;
        for (let i = 0; i < columnName.length; i++) {
            colIx= colIx * 26 + base.indexOf(columnName[i]) + 1;
        }
        colIx = colIx -1; //fix Index Shift
        return data[rowIx] ? data[rowIx][colIx] : undefined;
    }

    async function updateGoogleTableData(parsed) {
        const tableData = await parseGoogleTable();
        for (const element of tableData) {
            const sheetURL = 'https://docs.google.com/spreadsheets/d/' + element.id + '/gviz/tq?sheet=' + element.sheet;
            const tsvArray = await fetchDataFromGoogle(sheetURL);
            //console.log("Updated Data: ", tsvArray);
            if (tsvArray.length > 0) {
                element.value = getCellData(element.cell, tsvArray);
                if (!parsed) parsed = {};
                if (!(element.key in parsed)) {
                    parsed[element.key] = element.value;
                }
            }
        }
    }

    // Uncomment the following lines to periodically update data
    /*
        const fetchInterval = 2000;
        setTimeout(() => {
            setInterval(() => {
                updateGoogleTableData()
            }, fetchInterval)
        }, 4000);
        */
</script>
<script>
    "use strict"
    let lottieTemplate = ${jsonData};
    let playStatus = "";
    let nextCount = 1;
    let nextTotal = 0;
    let showInfo = false;
    let currentSegment;
    let currentSegmentFrames;
    let animReady = createDeferredPromise();
    let animLoaded = createDeferredPromise();
    let animation;
    let newAnimation;
    let stopExist = false;
    let showLogs = false;
    let imagesPathPrefix = ${imagePath};
    let updateCounter = 1;
    let currentFrame;
    let fetchSheet = true;
    let lottieState = "pause";

    function createDeferredPromise() {
        let resolver, rejecter;
        const promise = new Promise((resolve, reject) => {
            resolver = resolve;
            rejecter = reject;
        });
        return {
            promise,
            resolve: resolver,
            reject: rejecter
        };
    }

    //add font-face from data.json  //Credits to HeineFro  @https://github.com/HeineFro
    const addFont = (fam, path) => {
        let newFont = document.createElement('style');
        newFont.appendChild(document.createTextNode(`\
            @font-face {\
                font-family: ${fam};\
                src: url('${path}');\
            }\
            `));
        document.head.appendChild(newFont);
    }

    function pause (sec) {
        return new Promise((resolve, reject) => {
            setTimeout(()=>{
                resolve("Die "+ sec +" Sekunden Pause ist vorbei")
            },sec*1000)
        })
    }

    function loadFonts() {
        return new Promise((resolve, reject) => {
            const fonts = lottieTemplate.fonts.list;
            let fontPromises = [];

            for (const font of fonts) {
                if (font.fPath !== '') {
                    fontPromises.push(new FontFace(font.fFamily, `url(${font.fPath})`).load());
                }
            }

            Promise.all(fontPromises)
                .then(() => resolve('Fonts loaded'))
                .catch(err => reject(err));
        });
    }

    //updates Images Assets by there Refid  //Credits to HeineFro  @https://github.com/HeineFro
    function updateAssetsByRefid(array, searchValue, newValue) {
        const foundObject = array.find(obj => obj['id'] === searchValue);

        if (foundObject) {
            foundObject['u'] = imagesPathPrefix
            foundObject['p'] = newValue;
            foundObject['e'] = 0
            return foundObject;
        }

        return null;
    }

    //fix and check markers
    lottieTemplate.markers.forEach((marker) => {
        let name = marker.cm;
        marker.cm = "name:" + name.toLowerCase();

        if (name.includes("next")) {
            nextTotal++
        }
        if (name == "stop") {
            stopExist = true;
        }
    })
    let lottieTemplateNew = {...lottieTemplate};

    async function update(rawData) {
        lottieTemplateNew = {...lottieTemplate};
        let parsed;

        if (rawData) {
            if (rawData.startsWith("<templateData>")) {
                let parser = new DOMParser();
                let xmlDoc = parser.parseFromString(rawData, "text/xml");

                let json = {};

                let components = xmlDoc.getElementsByTagName("componentData");
                for (let component of components) {
                    let id = component.getAttribute("id");
                    let dataElement = component.getElementsByTagName("data")[0];
                    json[id] = dataElement.getAttribute("value");
                }
                parsed = json;
            } else {
                parsed = JSON.parse(rawData);
            }
            for (let key of Object.keys(parsed)) {
                if (key === "_templateInfo") showInfo = true;
                if (key === "_debug") showLogs = true;
                if (key === "epochID") imagesPathPrefix = "";
                if (key === "_stopFetch") fetchSheet = false;
            }
            for (let key of Object.keys(parsed)) {
                lottieTemplateNew.layers.forEach((layer) => {
                    if (layer.nm === key) {
                        if ('refId' in layer) {
                            updateAssetsByRefid(lottieTemplateNew.assets, layer.refId, parsed[key]);
                        } else {
                            layer.t.d.k[0].s.t = parsed[key];
                        }
                    }
                })
            }
        }

        if(fetchSheet && googleTableCells) {
            await updateGoogleTableData(parsed);
            const tableData = await parseGoogleTable();
            tableData.forEach((element)=>{
                if (!parsed) parsed = {};
                if (!(element.key in parsed)){
                    parsed[element.key] = element.value;
                }
            });
        }

        /*if(parsed){
            for (let key of Object.keys(parsed)) {
                lottieTemplateNew.layers.forEach((layer) => {
                    if (layer.nm === key) {
                        layer.t.d.k[0].s.t = parsed[key]
                    }
                })
            }
        }*/

        if (playStatus === "") {
            animation = bodymovin.loadAnimation({
                container: document.getElementById("animation1"),
                renderer: "svg",
                loop: false,
                autoplay: false,
                animationData: lottieTemplateNew,
            })
            let fonts = animation.renderer.data.fonts.list;
            for (const font in fonts) {
                let family = fonts[font].fFamily;
                let fontPath = fonts[font].fPath;
                if (fontPath !== '') {
                    addFont(family, fontPath);
                }
            }
            animReady = new Promise((resolve, reject) => {
                animation.addEventListener("DOMLoaded", function () {
                    if (showLogs) console.log("Template - Ready");
                    resolve("ready");
                })
            })

            animation.addEventListener("_play", function () {
                lottieState = "play"
                console.log("LottieState - Play")
            })

            animation.addEventListener("_pause", function () {
                lottieState = "stop"
                console.log("LottieState - pause")
            })

            animation.addEventListener("enterFrame", () => {
                for (let marker of lottieTemplate.markers) {
                    if (marker.cm === "name:" + currentSegment) {
                        currentSegmentFrames = marker.tm;
                    }
                }
                currentFrame = animation.currentFrame + currentSegmentFrames;
                if (showLogs) console.log(`Template - Current Frame: ${currentFrame}`);
            })

            updateTimeField("animation" + updateCounter);

            await animReady.promise;
            animation.goToAndStop(0, true);
            playStatus = "loaded";
            currentSegment = "start";
            animLoaded.resolve("Template - Animation is Ready");

        }
        if (playStatus === "play") {
            updateCounter++;
            let newDiv = document.createElement("div");
            newDiv.id = "animation" + updateCounter;
            document.body.appendChild(newDiv);

            newAnimation = bodymovin.loadAnimation({
                container: document.getElementById("animation" + updateCounter),
                renderer: "svg",
                loop: false,
                autoplay: false,
                animationData: lottieTemplateNew,
            })

            newAnimation.addEventListener("DOMLoaded", function () {
                if (showInfo) console.log("Template - updated Animation Ready");
                newAnimation.goToAndStop(currentFrame, true);
                animation.destroy();
                document.getElementById("animation" + (updateCounter - 1)).remove();
                animation = newAnimation;
                animation.addEventListener("enterFrame", () => {
                    for (let marker of lottieTemplate.markers) {
                        if (marker.cm === "name:" + currentSegment) {
                            currentSegmentFrames = marker.tm;
                        }
                    }
                    currentFrame = animation.currentFrame + currentSegmentFrames;
                    if (showLogs) console.log(`Current Frame: ${currentFrame}`);
                })

                animation.addEventListener("_play", function () {
                    lottieState = "play"
                    console.log("LottieState - Play")
                })
                animation.addEventListener("_pause", function () {
                    lottieState = "stop"
                    console.log("LottieState - pause")
                })

                updateTimeField("animation" + updateCounter);

                newAnimation = null;
            })
        }
        if (showInfo) info();
    }


    async function play() {
        console.log(await animLoaded.promise);
        await animReady;
        await loadFonts();
        animation.goToAndPlay("start", true);
        playStatus = "play";
        currentSegment = "start";
        if (showLogs) console.log("Template - Play 'start' marker");
        updateTimeField("animation" + updateCounter);
    }


    function stop() {
        if (stopExist) {
            animation.goToAndPlay("stop", true);
            if (showLogs) console.log("Template - Play 'stop' Marker");
        } else {
            if (showLogs) console.log("Template - No 'stop' marker - destroy Animation");
            animation.destroy();
        }
        playStatus = "stop";
    }

    function next() {
        if (nextCount > nextTotal && stopExist) {
            animation.goToAndPlay("stop", true);
            if (showLogs) console.log("Template - No 'next' marker left - Play 'stop' Marker");
        } else {
            if (showLogs) console.log("Template - Play 'next" + nextCount + "' Marker");
            animation.goToAndPlay("next" + nextCount, true);
            currentSegment = "next" + nextCount;
            nextCount++;
        }
    }

    function info() {
        animation.destroy();
        let title = document.createElement("h1");
        title.appendChild(document.createTextNode("These are the names of your After-Effects layers starting with \"_\"."));
        document.body.appendChild(title);

        lottieTemplate.layers.forEach((layer) => {
            if (layer.nm.startsWith("_")) {
                let nameElement = document.createElement("p");
                let text = document.createTextNode(layer.nm);
                let br = document.createElement("br");
                nameElement.appendChild(text);
                document.body.appendChild(nameElement);
                document.body.appendChild(br);
            }
        })

        let nameElement = document.createElement("p");
        let text = document.createTextNode("Your image path is: '" + imagesPathPrefix + "'");
        let br = document.createElement("br");
        nameElement.appendChild(text);
        document.body.appendChild(nameElement);
        document.body.appendChild(br);
    }
</script>
<!-- Lottie.js-->
<script>
    ${lottieData}
</script>
</body>
</html>